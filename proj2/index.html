<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
</head>
<body>
<h1 id="project-2">Project 2</h1>
<p>In this project, I implemented code to generate and manipulate Bezier curves, surfaces, and triangle meshes represented using the half-edge data structure. I found the mesh upsampling implementation particulary interesting, since it demonstrated how composing relatively simple operations (edge splitting and flipping) could yield surprisingly nontrivial results.</p>
<h2 id="part-1">Part 1</h2>
<p>de Casteljiau's algorithm is an iterative algorithm that repeatedly computes weighted averages of input points, until we obtain a single point. By changing the weight parameter, we can trace out a curve that depends on the inputs, known as a <em>Bezier curve</em>.</p>
<p>More precisely, we start with a weight parameter <span class="math inline"><em>t</em></span> from <span class="math inline">[0, 1]</span>. Then, in each iteration, we take adjacent pairs of input points <span class="math inline"><em>p</em><sub>1</sub></span> and <span class="math inline"><em>p</em><sub>2</sub></span> and average them based on this parameter to produce <span class="math inline">(1 − <em>t</em>)<em>p</em><sub>1</sub> + <em>t</em><em>p</em><sub>2</sub></span>. Since we do this for each adjacent pair, each iteration produces one fewer output point than it has inputs. So starting with <span class="math inline"><em>n</em></span> points, after <span class="math inline"><em>n</em> − 1</span> iterations, we end up with a single point. Notice that when <span class="math inline"><em>t</em> = 0</span> and <span class="math inline"><em>t</em> = 1</span>, this final point is the start or end control , respectively. And for values of <span class="math inline"><em>t</em></span> in between, we sweep out a curve that is part of a degree-<span class="math inline">(<em>n</em> − 1)</span> polynomial.</p>
<p>The following images show each stage of the Bezier interpolation process, culminating with a final point.</p>
<p><img src="bezier0.png" alt="bezier0.png" style="width:49.0%" /> <img src="bezier1.png" alt="bezier1.png" style="width:49.0%" /> <img src="bezier2.png" alt="bezier2.png" style="width:49.0%" /> <img src="bezier3.png" alt="bezier3.png" style="width:49.0%" /> <img src="bezier4.png" alt="bezier4.png" style="width:49.0%" /> <img src="bezier5.png" alt="bezier5.png" style="width:49.0%" /></p>
<p>The full Bezier curve is below, as is a slightly different curve formed by slightly perturbing the original control points:</p>
<p><img src="bezierc.png" alt="bezierc.png" style="width:49.0%" /> <img src="beziermoved.png" alt="beziermoved.png" style="width:49.0%" /></p>
<h2 id="part-2">Part 2</h2>
<p>To extend Bezier curves to 3D (forming <em>Bezier surfaces</em>) we now require <span class="math inline"><em>n</em><sup>2</sup></span> points arranged in a logical grid <code>points[N][N]</code>, between which we will form the surface. We will do so by iterating over the dimension. First, for a given parameter <span class="math inline"><em>s</em></span>, we will compute the 1D Bezier-interpolated point for each &quot;row&quot; of of our control points. This gives us <span class="math inline"><em>n</em></span> new points, which describe a Bezier curve (using the technique described above, with an additional parameter <span class="math inline"><em>t</em></span> used to select a point on this curve). So by varying <span class="math inline"><em>s</em></span>, we can &quot;sweep'' this curve across the entire grid, to form a Bezier &quot;patch&quot;. Composing many of these points together gives us a surface, such as the teapot shown below: <img src="bezierteapot.png" alt="bezierteapot.png" /></p>
<h2 id="part-3">Part 3</h2>
<p>Here, we needed to compute the normal vector of each face, whose length equals the area of the face. Then, we took the average of all these area-weighted normals around a given vertex, and re-normalized to compute the <em>area-weighted vertex normals</em>.</p>
<p>To compute the normal vector of each face, we took cross products between adjacent position vectors of the face's vertices. For triangular faces (which we are working with) this is equivalent to taking the cross product of vectors representing two edges, which is well known to yield a vector normal to the face and with area equal to the face - exactly what is desired. We then simply iterated over the faces adjacent to each vertex (ignoring boundary faces), summed up all these normal vectors, and normalized.</p>
<p>Renders of the teapot with flat shading and Phong shading, respectively, follow: <img src="teapotflat.png" alt="teapotflat.png" style="width:49.0%" /> <img src="teapotphong.png" alt="teapotphong.png" style="width:49.0%" /></p>
<h1 id="part-4">Part 4</h1>
<p>I implemented the edge-flip operation in the standard manner. Starting from the target edge, I traversed its local neighborhood to obtain the relevant edges, vertices, and faces (assuming that all faces are triangular). If the input edge was a boundary edge, I returned with no action. Otherwise, I updated the half-edges of the target edge to go between the &quot;opposite&quot; vertices on the two adjacent faces, and updated the faces, vertices, and edges accordingly to keep the graph consistent.</p>
<p>There were no interesting implementation details. To make implementation simple, I drew a diagram of the relevant part of the mesh, and labelled each quantity, to make it obvious what needed to change. Then I could confidently write an implementation that was immediately bug-free (as far as I can tell!).</p>
<p>Here, we show a mesh before and after edge-flips. Each image highlights the edge that is flipped in its successor:</p>
<p><img src="flip0.png" alt="flip0.png" style="width:49.0%" /> <img src="flip1.png" alt="flip1.png" style="width:49.0%" /> <img src="flip2.png" alt="flip2.png" style="width:49.0%" /> <img src="flip3.png" alt="flip3.png" style="width:49.0%" /></p>
<h1 id="part-5">Part 5</h1>
<p>I implemented the edge-split operation in a similar manner to edge-flips. The only element of note was that now, new elements had to be added to the mesh, which I created using the built-in methods. As before, I drew diagrams of the entire process, labeling each edge, half-edge, face, and vertex, so I could simply directly write out the implementation in code. Unlike edge-flips, here I simply updated every relevant parameter of each mesh object, rather than trying to make the minimal set of changes, to ensure the implementation was bug-free (which, again, I believe it to be). I also set the <code>edge.isNew</code> parameters in preparation for the next part.</p>
<p>Here, we show a sequence of edge splits and flips on a mesh. The sequence of operations performed is: split, split, split, flip, split, each time acting on the highlighted edge:</p>
<p><img src="split0.png" alt="split0.png" style="width:49.0%" /> <img src="split1.png" alt="split1.png" style="width:49.0%" /> <img src="split2.png" alt="split2.png" style="width:49.0%" /> <img src="split3.png" alt="split3.png" style="width:49.0%" /> <img src="split4.png" alt="split4.png" style="width:49.0%" /> <img src="split5.png" alt="split5.png" style="width:49.0%" /></p>
<h2 id="part-6">Part 6</h2>
<p>I implemented loop subdivision as per the skeleton code. First, I iterated over each current vertex, marked each as <code>isNew = false</code>, and computed the <code>newPosition</code> based on the old positions of its neighbors and the supplied formula. Then, I iterated over each edge, marked it as <code>isNew = false</code>, and computed its <code>newPosition</code> (i.e. that of the vertex at its center, once we split the edge) using the supplied formula, traversing the local mesh to locate the vertices not at the endpoints of the edge. Third, I looped over all the existing edges, split them, and set the position of the new vertex to that of the <code>edge.newPosition</code>. I used a counter to ensure we only looped over existing (i.e. non-split) edges, since new edges are appended to the end of the mesh edgelist. Next, I looped over all the edges again, flipping any that satisfied the desired criteria (<code>isNew</code> and between a new and old vertex). Finally, I updated the positions of all vertices to their <code>newPosition</code>.</p>
<p>I encountered no major bugs in this implementation, since most of the mesh traversal logic was encapsulated in the edge flipping and splitting functions, which were written carefully to ensure no bugs.</p>
<p>In general, as mesh subdivision is repeatedly applied on a mesh, it appears to become more &quot;rounded&quot;, with sharp corners becoming smoother curves. See the following screenshots showing what happens to the corner of a cube:</p>
<p><img src="cube0.png" alt="cube0.png" style="width:49.0%" /> <img src="cube1.png" alt="cube1.png" style="width:49.0%" /> <img src="cube2.png" alt="cube2.png" style="width:49.0%" /> <img src="cube3.png" alt="cube3.png" style="width:49.0%" /> <img src="cube4.png" alt="cube4.png" style="width:49.0%" /> <img src="cube5.png" alt="cube5.png" style="width:49.0%" /></p>
<p>By &quot;pre-splitting&quot; edges near a corner, we can reduce this effect. Intuitively, it is as if we have more &quot;sample points&quot; to define the shape of the corner, so smoothing has less of an impact. We see this to be the case, splitting some edges near one corner in an ad-hoc manner, then observing how the corner stays better defined as we repeatedly apply subdivision.</p>
<p><img src="cubesharp0.png" alt="cubesharp0.png" style="width:49.0%" /> <img src="cubesharp1.png" alt="cubesharp1.png" style="width:49.0%" /> <img src="cubesharp2.png" alt="cubesharp2.png" style="width:49.0%" /> <img src="cubesharp3.png" alt="cubesharp3.png" style="width:49.0%" /></p>
<p>Finally, we note that the asymmetric output of repeatedly subdividing the (unmodified) cube is because, although the actual shape is symmetric, the mesh triangulation is not. By splitting all the face diagonal edges to make the triangulation symmetrical, we can then apply subdivision to get a perfectly symmetrical output:</p>
<p><img src="cubesym0.png" alt="cubesym0.png" style="width:49.0%" /> <img src="cubesym1.png" alt="cubesym1.png" style="width:49.0%" /> <img src="cubesym2.png" alt="cubesym2.png" style="width:49.0%" /> <img src="cubesym3.png" alt="cubesym3.png" style="width:49.0%" /></p>
<p>Of course, the final output is not <em>spherically</em> symmetric, but at least it is symmetrical about the same axes that the cube initially was.</p>
<p>Website link: <a href="https://cal-cs184-student.github.io/sp22-project-webpages-rahularya50/proj2/" class="uri">https://cal-cs184-student.github.io/sp22-project-webpages-rahularya50/proj2/</a>.</p>
</body>
</html>
