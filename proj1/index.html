<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../pandoc.css" type="text/css" />
</head>
<body>
<h1 id="project-1">Project 1</h1>
<p>In this project, I filled in code to complete the implementation of a SVG renderer. Specifically, I implemented logic to (semi-efficiently) identify which pixels lie inside a triangle based on the location of its vertices. I implemented supersampling-based anti-aliasing to reduce &quot;jaggies&quot; in the rendering. For triangles, I also implemented color and texture interpolation based on barycentric coordinates. The textures were sampled using various forms of interpolation, using mipmaps to efficiently remove high-frequency artifacts as appropriate.</p>
<h2 id="task-1">Task 1</h2>
<p>Each triangle is defined by three points <span class="math inline">(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>i</em></sub>)</span> for <span class="math inline">0 ≤ <em>i</em> &lt; 3</span>. We first compute the bounding box of the triangle, bounded by the minimum and maximum x and y coordinates of these three points. Then, we loop over each test point <span class="math inline">(<em>x</em>, <em>y</em>)</span> within this bounding box to check if it lies inside the triangle.</p>
<p>To do so, we make the following observation. Consider a vector representing the direction of a line passing through the origin. Rotate it 90 degrees counterclockwise. Then project a test point onto this vector using dot products. The sign of this projection is positive if the test point is to the &quot;left&quot; of the original line (facing along the direction vector), zero if it lies on the line, and negative if it lies to the &quot;right&quot;. By translating all coordinates, we can make a similar determination for the position of a point with respect to a line not passing through the origin, so long as we know its direction vector and at least one point on the line.</p>
<p>Now, note that the triangle's vertices are ordered so they are oriented either &quot;clockwise&quot; or &quot;counter-clockwise&quot;. If clockwise, then a point lies inside the triangle iff it is not to the left of any line between two consecutive vertices. If counter-clockwise, then a point lies inside the triangle so long as it is not to the right of any line between consecutive vertices. So we can use the above sign-of-the-dot-product test to check if a point lies inside the triangle in either orientation. If so, we color it in, and otherwise we leave it blank.</p>
<p>Mathematically, the test looks like this (in pseudo-code):</p>
<pre><code>// let (x, y) be our test point
// let pts[i] = (xi, yi), where pts[0] == pts[3]
cw = true;
ccw = true;
for i in 0..3:
    // the line goes from pts[i] to pts[i+1]
    // treat pts[i+1] as the offset, to translate our line through the origin
    // let (dx, dy) be the direction vector of the line
    dx = pts[i+1][0] - pts[i][0];
    dy = pts[i+1][1] - pts[i][1];

    // we are taking the inner product of (-dy, dx) with ((x, y) - offset)
    auto l = -(x - pts[i+1][0]) * dy + (y - pts[i+1][1]) * dx;

    // if we lie to the left or the right of a line,
    // we rule out the clockwise/counter-clockwise cases, respectively
    if (l &gt; 0) {
        cw = false;
    }
    if (l &lt; 0) {
        ccw = false;
    }
}

// if we are consistent with one orientation, then we are inside the triangle!
inside_triangle = cw || ccw;</code></pre>
<p>My algorithm literally just checks every sample within the bounding box, so it is obviously no worse than such an approach.</p>
<p>A rendering of <code>basic/test4.svg</code> follows: <img src="q1.png" alt="q1.png" /></p>
<p>The inspector is zoomed in on the rightmost coerner of the red triangle. We see jaggies due to the lack of anti-aliasing, as the triangle thins to a point.</p>
<h2 id="task-2">Task 2</h2>
<p>In supersampling, we increase the size of the <code>sample_buffer</code> to <code>width * height * sample_rate</code>. We index into it as <code>sample_buffer[y * width * sample_scale + x]</code>, where <code>sample_scale * sample_scale = sample_rate</code>, and <code>x</code> and <code>y</code> are the supersampled coordinates such that <code>0 &lt;= x &lt; sample_scale * width</code>, and <code>0 &lt;= y &lt; sample_scale * height</code>.</p>
<p>The <code>fill_pixel(x0, y0)</code> function is modified to fill in all points <code>(x, y)</code> where <code>x0 * sample_scale &lt;= x &lt; (x0 + 1) * sample_scale</code> and analogously for <code>y</code>, so we are essentially filling in a small &quot;box&quot; in the buffer. So for points and lines, which use this function, supersampling has no effect.</p>
<p>However, we do modify the <code>rasterize_triangle</code> function to test each sample in the aforementioned &quot;box&quot; for membership in the triangle separately. This is useful, since then if the border of the triangle passes &quot;partially&quot; through the box associated with an actual output pixel, we end up coloring in that output box &quot;partly&quot;, making the borders &quot;fuzzier&quot; and reducing the effects of jaggies. The fuzziness comes from the color averaging process as we write to the framebuffer.</p>
<p>Finally, we modify the <code>resolve_to_framebuffer</code> function to average the color of each point in the &quot;box&quot; corresponding to an actual output point <code>(x, y)</code>, before writing to the <code>rgb_framebuffer_target</code>.</p>
<p>Below, we show how <code>basic/test4.svg</code> is rendered with sample rates 1, 4, 9, and 16 (left-to-right, then top-to-bottom):</p>
<p><img src="q2a.png" alt="q2a.png" style="width:49.0%" /> <img src="q2b.png" alt="q2b.png" style="width:49.0%" /> <img src="q2c.png" alt="q2c.png" style="width:49.0%" /> <img src="q2d.png" alt="q2d.png" style="width:49.0%" /></p>
<p>Observe how the sharp corner of the triangle begins to &quot;blur&quot; into the background. This is because we can now shade pixels based on the &quot;fraction&quot; that they are covered by the triangle (estimated using supersampling), rather than shading them either entirely, or not at all, depending on whether the triangle covers the center point of the pixel. The greater the sample rate, the more accurate this estimate becomes, and so the &quot;smoother&quot; the corner becomes&quot;</p>
<h2 id="task-3">Task 3</h2>
<p>Cubeman is <a href="https://en.wikipedia.org/wiki/Dab_(dance)">dabbing</a>. <img src="q3.png" alt="q3.png" /></p>
<p>I rotated the arms and legs after their translation, and changed the color of the arms to make them more visible. I also scaled the head down in the y-direction and translated it vertically slightly.</p>
</body>
</html>
